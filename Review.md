# Зачем это нужно? #

Данная операционная система пишется только с целью приобритения опыта.
Автор не несет ответственности, подразумеваемой или явной, прямой или косвенной за последствия какого-либо использования или неиспользования данного продукта.
Подробнее см. текст открытой лицензии GNU (GNU General Public License, GPL)

# Компоненты системы #

Система на данный момент состоит из:
  * bootstrap кода (image/bootcode.bin, исходный код loader/bootcode.asm)
  * загрузчика (image/grldr, исходный код loader/grldr.asm)
  * ядра (image/kernel.exe, исходный код в kernel)

## bootstrap ##

Код загрузочного сектора считывает с диска первый кластер файла GRLDR из корневого каталога и передает ему управление

## Загрузчик ##

Загрузчик считывает с диска всю оставшуюся свою часть, после чего приступает к поиску и загрузке с диска ядра. Дальше инициализируется защищенный режим без страничной трансляции, подсчитывается объем доступной оперативной памяти. После чего включается страничная трансляция. Векторы IRQ переносятся вниз по таблице прерываний, инициализируется первый и единственный TSS, в котором будет испольняться весь дальнейший код (за небольшим исключением - ядро установит несколько task-gate'ов для специальных исключений, см. далее). Далее инициализируется Local APIC, I/O APIC.
После чего считанное ранее ядро проецируется по виртуальному адресу 80100000 и управление передается на его точку входа.

## Ядро ##

Ядро начинает свою инициализацию в фазе 0 с функции KiInitSystem(). В глобальную переменнную сохраняются аргументы, переданные ядру загрузчиком. Процессор опрашивается на наличие спецефических возможностей.
Ядро переходит к инициализации HAL (Hardware Abstraction Layer), вызывая HalInitSystem. HalInitSystem конфигурирует таймер Local APIC, конфигурирует второй канал таймера.
Ядро продолжает инициализацию и модифицирует таблицу прерываний, созданную загрузчиком - заменяются все вектора на собственные + для специальных исключений типа Double Fault или Stack Fault устанавливаются шлюзы задачи (task-gate) на новые созданные TSS, указывающие на обработчики соответствующих исключений и на действительные адреса стека.
Инициализация продолжается в менеджере процессов и потоков, который создает первичный поток из текущего потока управления и первичный процесс. Так же инициализируется встроенный отладчик ядра. После этого прерывания разрешаются и планировщик теоритически уже может переключать контексты. Практически он этого не делает - в системе всего один поток. Ядро продолжает инициализацию и переходит в фазу 1. Иниаилизируется менеджер памяти, который заполняет массив PPD (Physical Page Descriptor), описывающих каждую физическую страницу в системе и составляет список обнуленных и свободных страниц. Заполняется рабочий набор системного процесса. Дальше инициализируется менеджер объектов, создаются типы объектов и корневая директория менеджера объектов. Потом инициализируется менеджер ввода-вывода, который создает каталоги \Driver, \Device и другие и инициализирует типы объектов, соответствующие драйверу, устройству, файлу и другим объектам.
Ядро переходит в фазу инициализации 2 и еще раз вызывает менеджер памяти для инициализации. На фазе 2 менеждер памяти создает тип объектов EXTENDER для расширений ОС и директорию \Extender.
На этот момент ядро инициализировано и готово к работе. В тестовой версии далее создается три потока - два простых счетчика и один демонстрационный поток, который читает файл, тестирует менеджер памяти и подгружает драйвер hdd.sys